/*

This file will describe the user object

*/

// dependencies

const validate = require('validatior').validate;
const crypto = require('crypto');

// Private functions

// function that hashes a password with a salt
function hash (password, salt) {
	return crypto.createHmac('sha256', salt).update(password).digest('hex');
}


function createUserSalt(creation, secret) {
	return creation+secret;
}

// TODO: send an email to trully verify the email address
function validateUser(data) {
	let {firstname, lastname, password, email, address} = data;

	if (!validate(firstname).type('string').trim.length(l=>l>0).end(({value}) => firstname = value)) return false;
	if (!validate(lastname) .type('string').trim.length(l=>l>0).end(({value}) => lastname = value)) return false;
	if (!validate(password) .type('string')     .length(l=>l>0).end(({value}) => password = value)) return false;
	if (!validate(email)    .type('string').trim.length(l=>l>0 && l<=320).check(mail => /^[\w.]+@[\w.]+$/.test(mail)).end(({value}) => email = value)) return false;
	if (!validate(address)  .type('string').trim.length(l=>l>0).end(({value}) => address = value)) return false;

	return {firstname, lastname, password, email, address};
}

function User(userData) {

	let modified = false;


	// Getters
	this.firstname = function() {
		return userData.firstname;
	}
	this.lastname = function() {
		return userData.lastname;
	}
	this.address = function() {
		return userData.address;
	}
	this.email = function() {
		return userData.email;
	}
	this.secret = function() {
		return userData.secret;
	}
	this.creationdate = function() {
		return userData.creationdate;
	}
	this.hashedpassword = function() {
		return userData.hashedpassword;
	}


	// Setters
	function set(property, value) {

		// exit if no change needs to be made
		if (value === userData[property]) return;

		userData[property] = value;
		modified = true;
	}

	this.setFirstname(value) {
		// check if the lastname is valid
		if (!validate(value).type('string').trim.length(l=>l>0).end(({val}) => value = val)) return;

		set('firstname', value);
	}

	this.setLastname(value) {
		// check if the lastname is valid
		if (!validate(value).type('string').trim.length(l=>l>0).end(({val}) => value = val)) return;

		set('lastname', value);
	}

	this.setAddress(value) {
		// check if the lastname is valid
		if (!validate(value).type('string').trim.length(l=>l>0).end(({val}) => value = val)) return;

		set('address', value);
	}

	this.setPassword(value) {
		if (!validate(value) .type('string')     .length(l=>l>0).end(({val}) => value = val)) return;

		const hashed = hash(value, createUserSalt(userData.creationdate, userData.secret));

		set('hashedPassword', value);
	}

	this.save = function (cb) {
		if (!modified) cb(errors.nothingToUpdate());
	}
}

// Creation of the account of a user
// this data comes from a user so we need to validate it
User.create(data, cb) {
	// validate the user data
	const userData = validateUser(data);
	if (!userData) return cb(errors.missingField('firstname', 'lastname', 'password', 'email', 'address'), null);

	// extract

	userData.secret = Math.random().toString();
	userData.creationdate = Date.now().toString();
	userData.hashedpassword = hash(userData.password, createUserSalt(userData.creationdate, userData.secret));
	delete userData.password;

	const user = new User(userData);

	datalib.create('users', email, user, err => cb(err, user));
}


User.lookup(email, cb) {

	datalib.read('users', email, (err, userData) => {
		if (err || !userData) cb(err, null);
		cb(err, new User(userData));
	});
}

// delete the user and clean its associated data
User.delete(email, cb) {

}



// module that will be imported by the server
const lib = {};

// post
lib.create = User.create;

// get
lib.lookup = User.lookup;

// delete
lib.delete = User.delete;

module.exports = lib;
