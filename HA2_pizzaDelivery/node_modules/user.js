/*

This file will describe the user object

*/

// dependencies

const validator = require('validator');
const crypto = require('crypto');
const errors = require('errors');
const datalib = require('data');
const tokens = require('token');

const debug = console.log;

// Private functions

// function that hashes a password with a salt
function hash (password, salt) {
	return crypto.createHmac('sha256', salt).update(password).digest('hex');
}


function createUserSalt(creation, secret) {
	return creation+secret;
}

// TODO: send an email to trully verify the email address
function validateUser(data) {
	let {firstname, lastname, password, email, address} = data;

	if (!validator.validate(firstname).trim().length(l=>l>0).end(({value}) => firstname = value)) return false;
	if (!validator.validate(lastname) .trim().length(l=>l>0).end(({value}) => lastname = value)) return false;
	if (!validator.validate(password) .type('string')     .length(l=>l>0).end(({value}) => password = value)) return false;
	if (!validator.validate(email)    .trim().length(l=>l>0 && l<=320).check(mail => /^[\w.]+@[\w.]+$/.test(mail)).end(({value}) => email = value)) return false;
	if (!validator.validate(address)  .trim().length(l=>l>0).end(({value}) => address = value)) return false;

	return {firstname, lastname, password, email, address};
}

function User(userData) {

	let modified = false;


	// Getters

	this.get = function() {
		const data = {
			firstname: userData.firstname,
			lastname: userData.lastname,
			email: userData.email,
			address: userData.address
		}
		return data;
	}

	this.data = function() {
		return JSON.stringify(userData);
	}
	this.firstname = function() {
		return userData.firstname;
	}
	this.lastname = function() {
		return userData.lastname;
	}
	this.address = function() {
		return userData.address;
	}
	this.email = function() {
		return userData.email;
	}

	this.hashedPassword = function() {
		return userData.hashedPassword;
	}
	this.token = function() {
		return userData.token;
	}

	this.salt = function() {
		return createUserSalt(userData.creationdate, userData.secret);
	}


	// Setters
	function set(property, value) {

		// exit if no change needs to be made
		if (value === userData[property]) return;

		userData[property] = value;
		modified = true;
	}

	this.setFirstname = function (value) {
		// check if the lastname is valid
		if (!validator.validate(value).trim().length(l=>l>0).end(({val}) => value = val)) return;

		set('firstname', value);
	}

	this.setLastname = function (value) {
		// check if the lastname is valid
		if (!validator.validate(value).trim().length(l=>l>0).end(({val}) => value = val)) return;

		set('lastname', value);
	}

	this.setAddress = function (value) {
		// check if the lastname is valid
		if (!validator.validate(value).trim().length(l=>l>0).end(({val}) => value = val)) return;

		set('address', value);
	}

	this.setPassword = function (value) {
		if (!validator.validate(value).type('string').length(l=>l>0).end(({val}) => value = val)) return;

		const hashed = hash(value, createUserSalt(userData.creationdate, userData.secret));

		set('hashedPassword', value);
	}

	this.setToken = function (tokenId) {
		set('token', tokenId);
	}

	// update the user in db
	this.update = function () {
		if (!modified) return Promise.reject(errors.nothingToUpdate());
		const self = this;

		return new Promise(function(resolve, reject) {

			datalib.update('users', userData.email, self.data())
			.then(res => {
				modified = false;
				resolve();
			})
			.catch(reject);
		});
	}

	this.delete = function () {
		return datalib.delete('users', userData.email);
	}

	this.deleteAssociatedData = function () {
		const promises = this.associatedData.map(({dir,id}) => datalib.delete(dir, id));
		return Promise.all(promises);
	}


	this.associatedData = function () {
		return [
			{dir:'tokens', id:userData.token},
		];
	}
}

// Creation of the account of a user
// this data comes from a user so we need to validate it
User.create = (data) => {
	// validate the user data
	const userData = validateUser(data);
	if (!userData) return Promise.reject(errors.missingFields('firstname', 'lastname', 'password', 'email', 'address'), null);

	userData.token = '';
	userData.secret = Math.random().toString();
	userData.creationdate = Date.now().toString();
	userData.hashedPassword = hash(userData.password, createUserSalt(userData.creationdate, userData.secret));
	delete userData.password;

	const user = new User(userData);
	return new Promise(function(resolve, reject) {
		datalib.create('users', userData.email, user.data())
		.then(res => resolve(user))
		.catch(reject)
	});
}


User.lookup = (email) => {

	return new Promise(function(resolve, reject) {

		datalib.read('users', email)
		.then(userData => resolve(new User(userData)))
		.catch(reject)
	});

}

User.login = async function(email, password) {
	const authError = errors.authentification();
	if (!validator.validate(password).type('string').length(l=>l>0).end()) {
		authError.sysError = 'not valid password';
		return Promise.reject(authError);
	}
	if (!validator.validate(email).trim().length(l=>l>0 && l<=320).check(mail => /^[\w.]+@[\w.]+$/.test(mail)).end(({value}) => email = value)) {
		authError.sysError = 'not valid email';
		return Promise.reject(authError);
	}

	// lookup the user
	let user;
	try {
		user = await User.lookup(email);
	} catch (e) {
		return Promise.reject(authError.eat(e));
	}

	// verify that hashes are matching
	const hashedPassword = hash(password, user.salt());
	if (hashedPassword !== user.hashedPassword()) return Promise.reject(authError);

	// get the current token
	const tokenId = user.token();

	// will store the existing token or a new one if there was no token or if it was too old
	let token = null;

	// if the user have a tokenid then look it up
	if (tokenId) {
		try {
			token = await tokens.lookup(tokenId);
		} catch (e) {
			// treat this case the same as if there was no tokenid at all
			token = null;
		}
	}

	if (!token || token.expired({deleteonexpiration:true})) {
		try {
			token = await tokens.create(user.email());
		} catch (e) {
			return Promise.reject(authError.eat(e));
		}
		user.setToken(token.id());
		await user.update(); // if no await then my test fails because it's trying to read the user data at the same time
	}
	else {
		try {
			await token.update();
		}
		catch(e) {
			return Promise.reject(authError.eat(e));
		}
	}

	return Promise.resolve(token);
}




// module that will be imported by the server
module.exports = {
	create:User.create,
	lookup:User.lookup,
	login:User.login,
};
